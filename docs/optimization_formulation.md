# Reformulated Optimization Problem: Task Completion Maximization with TDMA

## System Model

### Network Components
- **M** IoT devices with Poisson task arrivals (λ_m)
- **N** UAVs with time-varying positions and velocities
- **1** Ground base station (fixed position)
- **T** time indices for trajectory planning

### Task Model
Each task k generated by device m has:
- `D_k`: Data size (bits)
- `C_k`: Required computation cycles
- `t_gen_k`: Generation time
- `t_deadline_k`: Deadline time
- `slack_k = t_deadline_k - t_gen_k`

### TDMA Channel Access
- **Time Division Multiple Access (TDMA)**: Only one device transmits at a time
- **Full bandwidth allocation**: Each task gets BW_total when served
- **No bandwidth split**: Simplifies optimization (no b_m(t) variables)

## Decision Variables

### Primary Variables
```
x = [
    UAV_positions(t):     (2, N, T)  - Position of each UAV at each time
    UAV_velocities(t):    (2, N, T)  - Velocity of each UAV at each time
    offload_decision_k:   {local, BS, UAV_n}  - Where to process task k
    schedule_k:           Time slot when task k begins transmission
]
```

### Binary Indicators
```
δ_k^local ∈ {0, 1}  - 1 if task k processed locally
δ_k^BS ∈ {0, 1}     - 1 if task k offloaded to base station
δ_k^UAV_n ∈ {0, 1}  - 1 if task k offloaded to UAV n

Constraint: δ_k^local + δ_k^BS + Σ_n δ_k^UAV_n = 1  (exclusive choice)
```

## Objective Function

### Maximize Total Completed Tasks
```
maximize  Σ_k I_k^complete

where I_k^complete = {
    1   if T_k^serve ≤ slack_k AND channel_k is reliable
    0   otherwise
}
```

### Serving Time Components

**Local Processing:**
```
T_k^local = C_k / f_device_m

(No channel access needed - purely local computation)
```

**Base Station Offloading (with TDMA):**
```
T_k^BS = T_k^uplink_BS + T_k^compute_BS
       = D_k / R_k^BS + C_k / f_BS

where R_k^BS = BW_total × log2(1 + SNR_k^BS × |h_k^BS|²)
             ↑ Full bandwidth (TDMA)
```

**UAV Offloading (UAV n, with TDMA):**
```
T_k^UAV_n = T_k^uplink_UAV + T_k^compute_UAV
          = D_k / R_k^UAV_n + C_k / f_UAV_n

where R_k^UAV_n = BW_total × log2(1 + SNR_k^UAV_n × |h_k^UAV_n|²)
                ↑ Full bandwidth (TDMA)
```

**Note:** Downlink transmission time is negligible (result size << input size)

### Total Serving Time
```
T_k^serve = δ_k^local × T_k^local 
          + δ_k^BS × T_k^BS 
          + Σ_n δ_k^UAV_n × T_k^UAV_n
```

### Channel Reliability Constraint
```
P_k^reliable ≥ P_min

where:
P_k^reliable = {
    1                                           if δ_k^local = 1
    P_k^BS_success                              if δ_k^BS = 1
    P_k^UAV_n_success                           if δ_k^UAV_n = 1
    1 - P_k^BS_fail × P_k^UAV_n_fail           if dual offload
}

P_k^BS_success = exp(-SNR_threshold / SNR_avg^BS)
P_k^UAV_n_success = exp(-SNR_threshold / SNR_avg^UAV_n)
```

## Constraints

### 1. Task Completion Constraints
```
T_k^serve + t_wait_k ≤ slack_k,  ∀k ∈ completed tasks

where t_wait_k is the waiting time until TDMA slot is available
```

### 2. Offloading Decision Constraints
```
δ_k^local + δ_k^BS + Σ_n δ_k^UAV_n = 1,  ∀k

δ_k^local, δ_k^BS, δ_k^UAV_n ∈ {0, 1},  ∀k, n
```

### 3. TDMA Non-Overlapping Constraints
```
At most one uplink transmission at any time:

For any two tasks k1, k2 being offloaded (δ^BS or δ^UAV):
  schedule_k1 + T_uplink_k1 ≤ schedule_k2  OR
  schedule_k2 + T_uplink_k2 ≤ schedule_k1

Equivalently:
Σ_k I_k^transmitting(t) ≤ 1,  ∀t

where I_k^transmitting(t) = 1 if task k transmits at time t
```

### 4. UAV Dynamics Constraints
```
Position update:
x_n(t+1) = x_n(t) + v_n(t) × Δt,  ∀n, t

Velocity limits:
||v_n(t)|| ≤ v_max,  ∀n, t

Coverage area:
(x_n(t), y_n(t)) ∈ [0, SIDE]²,  ∀n, t
```

### 5. UAV Energy Constraints
```
E_n^total ≤ E_n^battery,  ∀n

where:
E_n^total = E_n^flight + E_n^compute

E_n^flight = Σ_t (P_hover + k_drag × ||v_n(t)||²) × Δt

E_n^compute = Σ_k δ_k^UAV_n × κ × f_UAV_n² × C_k
```

### 6. UAV CPU Capacity Constraints
```
At each time t, for each UAV n:
Σ_{k: serving at t} C_k / f_UAV_n ≤ Δt

Or equivalently (cumulative):
Σ_k δ_k^UAV_n × C_k ≤ f_UAV_n × T_total
```

### 7. Channel Reliability Constraints
```
For offloaded tasks:
P_k^reliable ≥ P_min,  ∀k where δ_k^BS = 1 or δ_k^UAV_n = 1

where P_min is minimum acceptable reliability (e.g., 0.95)
```

### 8. QoS Constraints (Optional)
```
Minimum completion rate per device:
(Σ_{k ∈ device m} I_k^complete) / (total tasks from m) ≥ η_min,  ∀m

where η_min is minimum completion ratio (e.g., 0.8)
```

## Optimization Formulation (Complete)

```
maximize    Σ_k I_k^complete
  x

subject to:
    (C1)  δ_k^local + δ_k^BS + Σ_n δ_k^UAV_n = 1,  ∀k
    
    (C2)  T_k^serve + t_wait_k ≤ slack_k,  ∀k with I_k^complete = 1
    
    (C3)  P_k^reliable ≥ P_min,  ∀k with δ_k^BS = 1 or δ_k^UAV_n = 1
    
    (C4)  Σ_k I_k^transmitting(t) ≤ 1,  ∀t  (TDMA constraint)
    
    (C5)  ||v_n(t)|| ≤ v_max,  ∀n, t
    
    (C6)  x_n(t+1) = x_n(t) + v_n(t) × Δt,  ∀n, t
    
    (C7)  (x_n(t), y_n(t)) ∈ [0, SIDE]²,  ∀n, t
    
    (C8)  E_n^flight + E_n^compute ≤ E_n^battery,  ∀n
    
    (C9)  Σ_{k: assigned to n} C_k ≤ f_UAV_n × T_total,  ∀n
    
    (C10) δ_k^local, δ_k^BS, δ_k^UAV_n ∈ {0, 1},  ∀k, n
```

## Problem Characteristics

### Complexity
- **Type**: Mixed Integer Nonlinear Programming (MINLP)
- **NP-Hard**: Due to binary offloading decisions and trajectory coupling
- **Non-convex**: Due to channel reliability terms and energy constraints

### Challenges
1. **Binary decisions**: Offloading choices (local/BS/UAV)
2. **Time coupling**: UAV trajectories affect future channel quality
3. **Stochastic channels**: Rayleigh fading introduces randomness
4. **Resource coupling**: Bandwidth and CPU shared across tasks
5. **Energy constraints**: Battery limits UAV trajectory and computation

## Solution Approaches

### 1. Decomposition Strategy (with TDMA)
```
Outer Loop (Slow Timescale):
  - Optimize UAV trajectories x_n(t), v_n(t)

Inner Loop (Fast Timescale):
  - Maintain TDMA schedule (queue of transmitting tasks)
  - For each task arrival:
    - Compute T_local
    - Compute T_BS, T_UAV_n (using full BW_total)
    - Compute P_reliable for each option
    - Estimate waiting time from TDMA queue
    - Select argmin{T_serve + t_wait} subject to P_reliable ≥ P_min
    - Update δ_k and TDMA schedule
```

### 2. Heuristic Algorithm (with TDMA)
```
1. Initialize UAV positions (clustering)
2. Initialize TDMA schedule queue Q = []
3. For each time slot t:
   a. Update UAV positions based on gradient
   b. Update TDMA queue (remove completed transmissions)
   c. For each task arrival k:
      - Compute T_local
      - Compute T_BS, T_UAV_n (using full BW_total)
      - Estimate t_wait from queue length
      - Evaluate P_reliable for each offload option
      - Choose option maximizing P_complete
      - If offload: add to TDMA queue Q
   d. Update energy consumption
4. Adjust trajectories if energy constraint violated
```

### 3. Learning-Based Approach (with TDMA)
```
State:
  - Current UAV positions
  - Device task queues
  - TDMA queue length and waiting time
  - Channel states
  - Remaining UAV energy

Action:
  - UAV velocities v_n(t)
  - Offloading decisions δ_k
  - TDMA scheduling priority

Reward:
  - Number of tasks completed in current time slot
  - Penalty for energy consumption
  - Penalty for deadline violations
  - Penalty for long TDMA waiting times
```

## Relaxations for Tractability

### 1. Continuous Relaxation
Replace binary variables with continuous:
```
δ_k ∈ [0, 1]  (fractional offloading)

Interpretation: δ_k fraction of task offloaded
```

### 2. Average Channel Model
Replace stochastic channel with average:
```
R_k ≈ E[R_k] = BW_total × log2(1 + SNR_avg)

where SNR_avg = P_r × E[|h|²] / σ_n²
```

### 3. Penalty Method
Convert hard deadline constraints to penalty:
```
maximize  Σ_k I_k^complete - λ × Σ_k max(0, T_k^serve - slack_k)²
```

### 4. Greedy Offloading Policy (TDMA-Aware)
```
For each task k at time t:
  1. Estimate TDMA waiting time from queue
  2. Compute T_local (no waiting)
  3. Compute T_BS, T_UAV_n (with full BW_total, includes waiting)
  4. Filter options by P_reliable ≥ P_min
  5. Choose option with minimum (T_serve + t_wait)
  6. If total_time > slack_k, reject task
  7. If offload chosen, add to TDMA queue
```

## Implementation Notes

### Task Completion Indicator
```python
def compute_task_completion(task, serving_time, channel_prob, P_min=0.95):
    """
    Returns 1 if task completed successfully, 0 otherwise.
    """
    meets_deadline = (serving_time <= task.slack)
    reliable_channel = (channel_prob >= P_min)
    return int(meets_deadline and reliable_channel)
```

### Offloading Decision (TDMA-Aware)
```python
def make_offloading_decision(task, iot_device, uav, bs, time_idx, tdma_queue, params):
    """
    Choose offloading target to minimize serving time (including TDMA waiting).
    
    Args:
        task: Task object
        iot_device: IoTDevice object
        uav: UAV object
        bs: BaseStation object
        time_idx: Current time index
        tdma_queue: Current TDMA transmission queue
        params: System parameters (BW_total, noise_var, snr_thresh, P_min)
    """
    options = []
    
    # Estimate TDMA waiting time
    t_wait = estimate_tdma_wait_time(tdma_queue, params.current_time)
    
    # Option 1: Local (no TDMA waiting)
    t_local = iot_device.compute_local_processing_time(task)
    p_local = 1.0  # Always reliable
    total_local = t_local  # No waiting
    options.append(('local', total_local, p_local))
    
    # Option 2: Base Station (uses full BW_total with TDMA)
    t_bs = compute_total_offload_time(
        task, iot_device, bs, time_idx, 
        H_M=params.H_M, H=params.H, F=params.F, 
        P_T=params.P_T, P_N=params.noise_var, 
        bandwidth=params.BW_total  # Full bandwidth!
    )
    p_bs = channel_success_probability(
        P_r_bs, params.noise_var, params.snr_thresh
    )
    if p_bs >= params.P_min:
        total_bs = t_bs + t_wait  # Includes TDMA waiting
        options.append(('bs', total_bs, p_bs))
    
    # Option 3: UAV (uses full BW_total with TDMA)
    t_uav = compute_total_offload_time(
        task, iot_device, uav, time_idx,
        H_M=params.H_M, H=params.H, F=params.F,
        P_T=params.P_T, P_N=params.noise_var,
        bandwidth=params.BW_total  # Full bandwidth!
    )
    p_uav = channel_success_probability(
        P_r_uav, params.noise_var, params.snr_thresh
    )
    if p_uav >= params.P_min:
        total_uav = t_uav + t_wait  # Includes TDMA waiting
        options.append(('uav', total_uav, p_uav))
    
    # Choose minimum total time among reliable options
    if not options:
        return None  # No reliable option available
    
    decision = min(options, key=lambda x: x[1])
    
    # Check deadline
    if decision[1] > task.slack:
        return None  # Cannot meet deadline
    
    return decision

def estimate_tdma_wait_time(tdma_queue, current_time):
    """
    Estimate waiting time until TDMA slot available.
    """
    if not tdma_queue:
        return 0.0
    
    # Sum remaining transmission times of all tasks in queue
    total_wait = 0.0
    for queued_task in tdma_queue:
        remaining = queued_task.end_time - current_time
        if remaining > 0:
            total_wait += remaining
    
    return total_wait
```

## Key Differences from Original Formulation

### Original (Throughput Maximization)
```
maximize  Σ_m log(Th_m)

Constraints:
  - Th_m ≥ R_min (QoS)
  - Deterministic channels
  - Fractional offloading o_m ∈ [0,1]
  - Bandwidth allocation b_m(t) per device
```

### New (Task Completion Maximization with TDMA)
```
maximize  Σ_k I_k^complete

Constraints:
  - T_k^serve + t_wait ≤ deadline (hard constraint)
  - Probabilistic channels with Rayleigh fading
  - Binary offloading decisions {local, BS, UAV_n}
  - TDMA constraint (one transmission at a time)
  - UAV energy limits
  - Trajectory optimization

Key advantages of TDMA:
  ✅ No bandwidth allocation variables
  ✅ Full BW_total per task
  ✅ Simpler problem formulation
  ✅ More realistic (matches 5G/LTE)
```

## TDMA Implementation Details

### Queue Management
```python
class TDMAQueue:
    def __init__(self):
        self.queue = []  # List of (task, start_time, end_time)
    
    def add_task(self, task, start_time, duration):
        end_time = start_time + duration
        self.queue.append((task, start_time, end_time))
    
    def get_next_available_slot(self, current_time):
        if not self.queue:
            return current_time
        
        # Find latest end time
        latest_end = max(end for _, _, end in self.queue)
        return max(current_time, latest_end)
    
    def remove_completed(self, current_time):
        self.queue = [(t, s, e) for t, s, e in self.queue if e > current_time]
```

### TDMA-Aware Scheduling
```python
def schedule_task_tdma(task, decision, tdma_queue, current_time):
    """
    Schedule task in TDMA queue if offloaded.
    """
    if decision == 'local':
        # No TDMA needed for local processing
        return current_time
    
    # Get next available TDMA slot
    start_time = tdma_queue.get_next_available_slot(current_time)
    
    # Compute uplink duration
    uplink_duration = task.length_bits / data_rate
    
    # Add to queue
    tdma_queue.add_task(task, start_time, uplink_duration)
    
    return start_time
```
